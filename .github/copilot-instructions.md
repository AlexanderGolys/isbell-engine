# Project Info
- managed by single dev - no need for team conventions or optimising for multiple contributors
- rendering engine designed mainly for rendering math visualisations in form of real time animations
- Windows only 
- written in C++23
- build system is premake5
- using OpenGL and GLFW as main libraries


## What should an agent suggest spontaneously
- when a macro can be replaced by typedefs and the change don't require additional changes in the code written so far (usually these will be macros of non-template types or fully specialised)
- when `std::vector` can be replaced by my `std::array` as it represent non-resizable sequence with size known at compile time. When it is not clear that the objects are non-resizable by assumptions, `std::vector` is preferred

## General instructions
- Do not edit this file
- Agents are allowed to edit only the test code or markdown files from ./docs directory spontineously, without being prompted. Both creating new documentation markdows, editing existing ones, writing new tests, adding new tests to existing test files and running tests to verify correctness of the code changes can be done spontaneously without prompting if it is relevant to some conversation that is ongoing.
- Try to mimick the existing style in the file
- Try to optimise the code to following principles with following order of priority:
  1. Clean and readable code 
  2. Shortest implementation
  3. Memory efficiency 
  4. Performance 
  5. Using known design patterns 
  6. Industry standards/best practices



# Code Style
##  Patterns that should b be should be AVOIDED in this codebase
- NEVER USE EMOJIS 
- NEVER use raw pointers unless to represent memory address to be dereferenced later. This in particular excludes the standard array types `T[N]` (always use `array<T, N>` )
- any use of `new`, `delete`, `malloc` or `free` unless it's in some copy-pasted code (like reading a file) and raw pointers are only its intermediate objects
- use of `std::` prefix if the referenced object is expected to be used in more than 3 different contexts (across entire codebase)
- importing entire global namespaces with `using namespace ...` directive (in both headers and source files)
- using operators `&&`, `||` and `!` (use `and`, `or` and `not` instead)
- including _`<windows.h>`_ anywhere outside of _`"windowsUtils.cpp"`_ file
- use `auto` for variables unless they are shared/unique pointers created in the same line with `make_shared`/`make_unique` or in the same line its type must be written down as template argument that cannot be deduced automatically
- using bitwise operators unless there is no other way to implement the logic (i.e. flags manipulation) or the meaning of bitwise operation is obvious (NOTE: operator `&` is often overloaded as composition of function types. This does not count as bitwise operation!)
- switch statements or if-else chains with more than 5 cases unless they are used under some newly defined enum class and listing its values cannot be avoided or any function formatting a string
- substituting macros or using a different alias referencing the same variable/argument/function, for example in definition and declaration of functions 
- don't use streams for I/O besides reading from files (no `<<`, `>>`, `std::cout`, `std::endl`) for logging. Use the standard library `<format>` to do all the formatting and logger macros from _`"logging.hpp"`_ instead
- avoid `do`-`while` loops, prefer `for` loops using iterators over the standard index-based `for` loops and any prefer any `for` loops over `while` loops
- never split definition and declaration if the body is empty or set with the method is set with `=` (e.g. pure abstract methods, `default`/`deleted` constructors etc)
- never use brackets for `if`/`for`/`while`/`else`/`else if` statements when you are not forced to do so.
- never import headers that include some header from this codebase not refered directly but with some relative path. In the build system all header paths are added to be found directly. 

## The style any generated code should FOLLOW CLOSELY
- Use following type aliases if and noly if the type falls into associated context:
    - `raw_data_ptr`- memory address with unspecified data type (alias for `const void*`)
    - `data_ptr<T>` - memory adress pointing to buffer of data of type `T` (alias for `const T*`)
    - `data_ptr_mut<T>` - mutable memory adress pointing to buffer of data of type `T` (alias for `T*`). It should not be used unless mutability is required by some interface that manages the buffer
    - `byte_size` - should uniquely identify measurements of memory size (that should be measured exclusively in bytes)
    - `array_len` - should uniquely identify lengths of sequential data structures as the measure of size (shouldn't be used as an index, only as the upper-bound on their value)
    - `array_index` - should represent index in sequential data structures (especially used to iterate over elements)
    - `vs_dim` - should represent dimension of vector spaces (or length of modules over more general commutative rings, like `ivec2`), usually used for number of components of vectors, or entries in a matrix. Shouldn't be used for vector space of large dimension, as these are usually generated by sequences which length should be represented with array_len, for example as in case of elements of class `Vector<T>` of `FiniteSequence<T>`
- use macro `HOM(X, Y)` for `std::function<Y(X)>` and `BIHOM(X, Y, Z)` for `std::function<Z(X, Y)>`

- Always split definitions and declarations **unless** 
  - the source file associated to the header doesnt exist 
  - the body has single line that is very short (like simple getters)
  - it is a template function and there is no section of the header file for template implementations at the end of the file
  - the body is empty (these should never be splitted into declaration and definition!)
- always start header files with `#pragma once `. Never define include guards or any other preprocessor directives besides macros
- Prefer typedefs to macros. 
- for logging use macros `LOG`, `LOG_WARN` and `LOG_ERROR` from _`"logging.hpp"`_:


## Handling Exceptions
- **NEVER** use `throw` keyword, use only my macros
- **NEVER** use exceptions that are defined outside _exceptions.h_
- in particular, **NEVER** use exceptions from `std::`
- dont put `__FILE__` and `__LINE__` manually as arguments. Use macros described below instead
- if the exception is thrown after checking some sondition, i.e. it is effectively assert, use macro `THROW_IF(condition, ExceptionClass, args...)`
``` 
    THROW_IF(not assertion_checker(), SystemError, "Something bad happened");
```
- use macro `THROW(ExceptionClass, args...)` for usual throws
```
    THROW(SystemError, "Something bad happened");
```
- if the error is caused by index out of bounds, use class `IndexOutOfBounds` with arguments `(index, size, container_name)` or `(index, size)` if container name is not known, obvious or it is a vector
- check if index is out of bounds automatically with macro `CHECK_OUT_OF_BOUNDS(index, size)`. It will throw appropriate exception if needed
- if the name of data structure where ther index is checked is important (useful for debugging), use macro `CHECK_OUT_OF_BOUNDS_NAME(index, size, container_name)`

## tl;dr 
### DO NOT USE: FORBIDDEN KEYWORDS
- EMOJIS
- `T*`, `T[]`
- `new`, `delete`, `malloc`, `free`
- `throw`
- `<<`, `>>`, `std::cout`, `std::cin`, `std::endl`
- `goto`, `do`-`while`
- `<windows.h>`
- `using namespace std`
- `using namespace glm`
- `std::vector`, `std::array`, `std::string` (`std::` prefix redundant)
- `std::runtime_error` (or any other `std::` exceptions)
- `Exception(msg, __FILE__, __LINE__)`
- `#ifndef`
- `std::function<Y(X)>`, `std::function<Z(X, Y)>`
- `auto` (except for smart pointers created with make_shared/make_unique)
- `&&`, `||`, `!`
- `<`, `>`, `|`
- `#include "../utils/logging.hpp"`

### PREFERED ALTERNATIVES 
| GOOD                     | BAD                                         |
|--------------------------|:--------------------------------------------|
| `typedef`/`using`        | `#define`                                   |
| `array<T, N>`            | `T[N]`                                      |
| `std::vector<T>`         | `vector<T>`                                 |          
| `data_ptr<T>`            | `const T*`                                  |
| `data_ptr_mut<T>`        | `T*`                                        |
| `raw_data_ptr`           | `const void*`                               |
| `#include "logging.hpp"` | `#include "../d/logging.hpp"`               |
| `THROW(ValueError, msg)` | `throw ValueError(msg, __FILE__, __LINE__)` |
| `HOM(X, Y)`              | `std::function<Y(X)>`                       |
| `BIHOM(X, Y, Z)`         | `std::function<Z(X, Y)>`                    |
| `and`                    | `&&`                                        |
| `or`                     | `                                           |
| `not`                    | `!`                                         |
| `uint`                   | `unsigned int`                              |
| `uchar`                  | `unsigned char`                             |



# Natural Language Conventions
- _"length of"_ mean the number of elements in some sequential data structure (like vector size). 
- _"size of"_ means bytes size
- _"property"_ means private member variable with getter method and possibly setter method
- By _"attribute"_ I mean usually any member variable


